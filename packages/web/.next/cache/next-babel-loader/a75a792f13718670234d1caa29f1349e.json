{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$create = require(\"@babel/runtime-corejs2/core-js/object/create\");\n\nvar _Object$setPrototypeOf = require(\"@babel/runtime-corejs2/core-js/object/set-prototype-of\");\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = _Object$setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? _Object$create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar LayoutManager_1 = require(\"../layoutmanager/LayoutManager\");\n/**\n * Created by talha.naqvi on 05/04/17.\n * You can create a new instance or inherit and override default methods\n * You may need access to data provider here, it might make sense to pass a function which lets you fetch the latest data provider\n * Why only indexes? The answer is to allow data virtualization in the future. Since layouts are accessed much before the actual render assuming having all\n * data upfront will only limit possibilites in the future.\n *\n * By design LayoutProvider forces you to think in terms of view types. What that means is that you'll always be dealing with a finite set of view templates\n * with deterministic dimensions. We want to eliminate unnecessary re-layouts that happen when height, by mistake, is not taken into consideration.\n * This patters ensures that your scrolling is as smooth as it gets. You can always increase the number of types to handle non deterministic scenarios.\n *\n * NOTE: You can also implement features such as ListView/GridView switch by simple changing your layout provider.\n */\n\n\nvar BaseLayoutProvider =\n/** @class */\nfunction () {\n  function BaseLayoutProvider() {\n    //Unset if your new layout provider doesn't require firstVisibleIndex preservation on application\n    this.shouldRefreshWithAnchoring = true;\n  }\n\n  return BaseLayoutProvider;\n}();\n\nexports.BaseLayoutProvider = BaseLayoutProvider;\n\nvar LayoutProvider =\n/** @class */\nfunction (_super) {\n  __extends(LayoutProvider, _super);\n\n  function LayoutProvider(getLayoutTypeForIndex, setLayoutForType) {\n    var _this = _super.call(this) || this;\n\n    _this._getLayoutTypeForIndex = getLayoutTypeForIndex;\n    _this._setLayoutForType = setLayoutForType;\n    _this._tempDim = {\n      height: 0,\n      width: 0\n    };\n    return _this;\n  }\n\n  LayoutProvider.prototype.newLayoutManager = function (renderWindowSize, isHorizontal, cachedLayouts) {\n    this._lastLayoutManager = new LayoutManager_1.WrapGridLayoutManager(this, renderWindowSize, isHorizontal, cachedLayouts);\n    return this._lastLayoutManager;\n  }; //Provide a type for index, something which identifies the template of view about to load\n\n\n  LayoutProvider.prototype.getLayoutTypeForIndex = function (index) {\n    return this._getLayoutTypeForIndex(index);\n  }; //Given a type and dimension set the dimension values on given dimension object\n  //You can also get index here if you add an extra argument but we don't recommend using it.\n\n\n  LayoutProvider.prototype.setComputedLayout = function (type, dimension, index) {\n    return this._setLayoutForType(type, dimension, index);\n  };\n\n  LayoutProvider.prototype.checkDimensionDiscrepancy = function (dimension, type, index) {\n    var dimension1 = dimension;\n    this.setComputedLayout(type, this._tempDim, index);\n    var dimension2 = this._tempDim;\n\n    if (this._lastLayoutManager) {\n      this._lastLayoutManager.setMaxBounds(dimension2);\n    }\n\n    return dimension1.height !== dimension2.height || dimension1.width !== dimension2.width;\n  };\n\n  return LayoutProvider;\n}(BaseLayoutProvider);\n\nexports.LayoutProvider = LayoutProvider;","map":{"version":3,"sources":["../../../../src/core/dependencies/LayoutProvider.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,eAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;AAEA;;;;;;;;;;;;;;;AAcA,IAAA,kBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,kBAAA,GAAA;AACI;AACO,SAAA,0BAAA,GAAsC,IAAtC;AAYV;;AAAD,SAAA,kBAAA;AAAC,CAdD,EAAA;;AAAsB,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAgBtB,IAAA,cAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAoC,EAAA,SAAA,CAAA,cAAA,EAAA,MAAA,CAAA;;AAOhC,WAAA,cAAA,CAAY,qBAAZ,EAAuE,gBAAvE,EAAuJ;AAAvJ,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IADX;;AAEI,IAAA,KAAI,CAAC,sBAAL,GAA8B,qBAA9B;AACA,IAAA,KAAI,CAAC,iBAAL,GAAyB,gBAAzB;AACA,IAAA,KAAI,CAAC,QAAL,GAAgB;AAAE,MAAA,MAAM,EAAE,CAAV;AAAa,MAAA,KAAK,EAAE;AAApB,KAAhB;;AACH;;AAEM,EAAA,cAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,gBAAxB,EAAqD,YAArD,EAA6E,aAA7E,EAAqG;AACjG,SAAK,kBAAL,GAA0B,IAAI,eAAA,CAAA,qBAAJ,CAA0B,IAA1B,EAAgC,gBAAhC,EAAkD,YAAlD,EAAgE,aAAhE,CAA1B;AACA,WAAO,KAAK,kBAAZ;AACH,GAHM,CAdX,CAmBI;;;AACO,EAAA,cAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,UAA6B,KAA7B,EAA0C;AACtC,WAAO,KAAK,sBAAL,CAA4B,KAA5B,CAAP;AACH,GAFM,CApBX,CAwBI;AACA;;;AACO,EAAA,cAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,IAAzB,EAAgD,SAAhD,EAAsE,KAAtE,EAAmF;AAC/E,WAAO,KAAK,iBAAL,CAAuB,IAAvB,EAA6B,SAA7B,EAAwC,KAAxC,CAAP;AACH,GAFM;;AAIA,EAAA,cAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,UAAiC,SAAjC,EAAuD,IAAvD,EAA8E,KAA9E,EAA2F;AACvF,QAAM,UAAU,GAAG,SAAnB;AACA,SAAK,iBAAL,CAAuB,IAAvB,EAA6B,KAAK,QAAlC,EAA4C,KAA5C;AACA,QAAM,UAAU,GAAG,KAAK,QAAxB;;AACA,QAAI,KAAK,kBAAT,EAA6B;AACzB,WAAK,kBAAL,CAAwB,YAAxB,CAAqC,UAArC;AACH;;AACD,WAAO,UAAU,CAAC,MAAX,KAAsB,UAAU,CAAC,MAAjC,IAA2C,UAAU,CAAC,KAAX,KAAqB,UAAU,CAAC,KAAlF;AACH,GARM;;AASX,SAAA,cAAA;AAAC,CAvCD,CAAoC,kBAApC,CAAA;;AAAa,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LayoutManager_1 = require(\"../layoutmanager/LayoutManager\");\n/**\n * Created by talha.naqvi on 05/04/17.\n * You can create a new instance or inherit and override default methods\n * You may need access to data provider here, it might make sense to pass a function which lets you fetch the latest data provider\n * Why only indexes? The answer is to allow data virtualization in the future. Since layouts are accessed much before the actual render assuming having all\n * data upfront will only limit possibilites in the future.\n *\n * By design LayoutProvider forces you to think in terms of view types. What that means is that you'll always be dealing with a finite set of view templates\n * with deterministic dimensions. We want to eliminate unnecessary re-layouts that happen when height, by mistake, is not taken into consideration.\n * This patters ensures that your scrolling is as smooth as it gets. You can always increase the number of types to handle non deterministic scenarios.\n *\n * NOTE: You can also implement features such as ListView/GridView switch by simple changing your layout provider.\n */\nvar BaseLayoutProvider = /** @class */ (function () {\n    function BaseLayoutProvider() {\n        //Unset if your new layout provider doesn't require firstVisibleIndex preservation on application\n        this.shouldRefreshWithAnchoring = true;\n    }\n    return BaseLayoutProvider;\n}());\nexports.BaseLayoutProvider = BaseLayoutProvider;\nvar LayoutProvider = /** @class */ (function (_super) {\n    __extends(LayoutProvider, _super);\n    function LayoutProvider(getLayoutTypeForIndex, setLayoutForType) {\n        var _this = _super.call(this) || this;\n        _this._getLayoutTypeForIndex = getLayoutTypeForIndex;\n        _this._setLayoutForType = setLayoutForType;\n        _this._tempDim = { height: 0, width: 0 };\n        return _this;\n    }\n    LayoutProvider.prototype.newLayoutManager = function (renderWindowSize, isHorizontal, cachedLayouts) {\n        this._lastLayoutManager = new LayoutManager_1.WrapGridLayoutManager(this, renderWindowSize, isHorizontal, cachedLayouts);\n        return this._lastLayoutManager;\n    };\n    //Provide a type for index, something which identifies the template of view about to load\n    LayoutProvider.prototype.getLayoutTypeForIndex = function (index) {\n        return this._getLayoutTypeForIndex(index);\n    };\n    //Given a type and dimension set the dimension values on given dimension object\n    //You can also get index here if you add an extra argument but we don't recommend using it.\n    LayoutProvider.prototype.setComputedLayout = function (type, dimension, index) {\n        return this._setLayoutForType(type, dimension, index);\n    };\n    LayoutProvider.prototype.checkDimensionDiscrepancy = function (dimension, type, index) {\n        var dimension1 = dimension;\n        this.setComputedLayout(type, this._tempDim, index);\n        var dimension2 = this._tempDim;\n        if (this._lastLayoutManager) {\n            this._lastLayoutManager.setMaxBounds(dimension2);\n        }\n        return dimension1.height !== dimension2.height || dimension1.width !== dimension2.width;\n    };\n    return LayoutProvider;\n}(BaseLayoutProvider));\nexports.LayoutProvider = LayoutProvider;\n//# sourceMappingURL=LayoutProvider.js.map"]},"metadata":{},"sourceType":"script"}