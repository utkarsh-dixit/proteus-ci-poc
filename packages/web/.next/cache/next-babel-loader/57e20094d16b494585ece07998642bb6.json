{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$create = require(\"@babel/runtime-corejs2/core-js/object/create\");\n\nvar _Object$setPrototypeOf = require(\"@babel/runtime-corejs2/core-js/object/set-prototype-of\");\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = _Object$setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? _Object$create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar CustomError_1 = require(\"../exceptions/CustomError\");\n\nvar LayoutManager =\n/** @class */\nfunction () {\n  function LayoutManager() {}\n\n  LayoutManager.prototype.getOffsetForIndex = function (index) {\n    var layouts = this.getLayouts();\n\n    if (layouts.length > index) {\n      return {\n        x: layouts[index].x,\n        y: layouts[index].y\n      };\n    } else {\n      throw new CustomError_1.default({\n        message: \"No layout available for index: \" + index,\n        type: \"LayoutUnavailableException\"\n      });\n    }\n  }; //You can ovveride this incase you want to override style in some cases e.g, say you want to enfore width but not height\n\n\n  LayoutManager.prototype.getStyleOverridesForIndex = function (index) {\n    return undefined;\n  };\n\n  return LayoutManager;\n}();\n\nexports.LayoutManager = LayoutManager;\n\nvar WrapGridLayoutManager =\n/** @class */\nfunction (_super) {\n  __extends(WrapGridLayoutManager, _super);\n\n  function WrapGridLayoutManager(layoutProvider, renderWindowSize, isHorizontal, cachedLayouts) {\n    if (isHorizontal === void 0) {\n      isHorizontal = false;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this._layoutProvider = layoutProvider;\n    _this._window = renderWindowSize;\n    _this._totalHeight = 0;\n    _this._totalWidth = 0;\n    _this._isHorizontal = !!isHorizontal;\n    _this._layouts = cachedLayouts ? cachedLayouts : [];\n    return _this;\n  }\n\n  WrapGridLayoutManager.prototype.getContentDimension = function () {\n    return {\n      height: this._totalHeight,\n      width: this._totalWidth\n    };\n  };\n\n  WrapGridLayoutManager.prototype.getLayouts = function () {\n    return this._layouts;\n  };\n\n  WrapGridLayoutManager.prototype.getOffsetForIndex = function (index) {\n    if (this._layouts.length > index) {\n      return {\n        x: this._layouts[index].x,\n        y: this._layouts[index].y\n      };\n    } else {\n      throw new CustomError_1.default({\n        message: \"No layout available for index: \" + index,\n        type: \"LayoutUnavailableException\"\n      });\n    }\n  };\n\n  WrapGridLayoutManager.prototype.overrideLayout = function (index, dim) {\n    var layout = this._layouts[index];\n\n    if (layout) {\n      layout.isOverridden = true;\n      layout.width = dim.width;\n      layout.height = dim.height;\n    }\n\n    return true;\n  };\n\n  WrapGridLayoutManager.prototype.setMaxBounds = function (itemDim) {\n    if (this._isHorizontal) {\n      itemDim.height = Math.min(this._window.height, itemDim.height);\n    } else {\n      itemDim.width = Math.min(this._window.width, itemDim.width);\n    }\n  }; //TODO:Talha laziliy calculate in future revisions\n\n\n  WrapGridLayoutManager.prototype.relayoutFromIndex = function (startIndex, itemCount) {\n    startIndex = this._locateFirstNeighbourIndex(startIndex);\n    var startX = 0;\n    var startY = 0;\n    var maxBound = 0;\n    var startVal = this._layouts[startIndex];\n\n    if (startVal) {\n      startX = startVal.x;\n      startY = startVal.y;\n\n      this._pointDimensionsToRect(startVal);\n    }\n\n    var oldItemCount = this._layouts.length;\n    var itemDim = {\n      height: 0,\n      width: 0\n    };\n    var itemRect = null;\n    var oldLayout = null;\n\n    for (var i = startIndex; i < itemCount; i++) {\n      oldLayout = this._layouts[i];\n\n      var layoutType = this._layoutProvider.getLayoutTypeForIndex(i);\n\n      if (oldLayout && oldLayout.isOverridden && oldLayout.type === layoutType) {\n        itemDim.height = oldLayout.height;\n        itemDim.width = oldLayout.width;\n      } else {\n        this._layoutProvider.setComputedLayout(layoutType, itemDim, i);\n      }\n\n      this.setMaxBounds(itemDim);\n\n      while (!this._checkBounds(startX, startY, itemDim, this._isHorizontal)) {\n        if (this._isHorizontal) {\n          startX += maxBound;\n          startY = 0;\n          this._totalWidth += maxBound;\n        } else {\n          startX = 0;\n          startY += maxBound;\n          this._totalHeight += maxBound;\n        }\n\n        maxBound = 0;\n      }\n\n      maxBound = this._isHorizontal ? Math.max(maxBound, itemDim.width) : Math.max(maxBound, itemDim.height); //TODO: Talha creating array upfront will speed this up\n\n      if (i > oldItemCount - 1) {\n        this._layouts.push({\n          x: startX,\n          y: startY,\n          height: itemDim.height,\n          width: itemDim.width,\n          type: layoutType\n        });\n      } else {\n        itemRect = this._layouts[i];\n        itemRect.x = startX;\n        itemRect.y = startY;\n        itemRect.type = layoutType;\n        itemRect.width = itemDim.width;\n        itemRect.height = itemDim.height;\n      }\n\n      if (this._isHorizontal) {\n        startY += itemDim.height;\n      } else {\n        startX += itemDim.width;\n      }\n    }\n\n    if (oldItemCount > itemCount) {\n      this._layouts.splice(itemCount, oldItemCount - itemCount);\n    }\n\n    this._setFinalDimensions(maxBound);\n  };\n\n  WrapGridLayoutManager.prototype._pointDimensionsToRect = function (itemRect) {\n    if (this._isHorizontal) {\n      this._totalWidth = itemRect.x;\n    } else {\n      this._totalHeight = itemRect.y;\n    }\n  };\n\n  WrapGridLayoutManager.prototype._setFinalDimensions = function (maxBound) {\n    if (this._isHorizontal) {\n      this._totalHeight = this._window.height;\n      this._totalWidth += maxBound;\n    } else {\n      this._totalWidth = this._window.width;\n      this._totalHeight += maxBound;\n    }\n  };\n\n  WrapGridLayoutManager.prototype._locateFirstNeighbourIndex = function (startIndex) {\n    if (startIndex === 0) {\n      return 0;\n    }\n\n    var i = startIndex - 1;\n\n    for (; i >= 0; i--) {\n      if (this._isHorizontal) {\n        if (this._layouts[i].y === 0) {\n          break;\n        }\n      } else if (this._layouts[i].x === 0) {\n        break;\n      }\n    }\n\n    return i;\n  };\n\n  WrapGridLayoutManager.prototype._checkBounds = function (itemX, itemY, itemDim, isHorizontal) {\n    return isHorizontal ? itemY + itemDim.height <= this._window.height : itemX + itemDim.width <= this._window.width;\n  };\n\n  return WrapGridLayoutManager;\n}(LayoutManager);\n\nexports.WrapGridLayoutManager = WrapGridLayoutManager;","map":{"version":3,"sources":["../../../../src/core/layoutmanager/LayoutManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CustomError_1 = require(\"../exceptions/CustomError\");\nvar LayoutManager = /** @class */ (function () {\n    function LayoutManager() {\n    }\n    LayoutManager.prototype.getOffsetForIndex = function (index) {\n        var layouts = this.getLayouts();\n        if (layouts.length > index) {\n            return { x: layouts[index].x, y: layouts[index].y };\n        }\n        else {\n            throw new CustomError_1.default({\n                message: \"No layout available for index: \" + index,\n                type: \"LayoutUnavailableException\",\n            });\n        }\n    };\n    //You can ovveride this incase you want to override style in some cases e.g, say you want to enfore width but not height\n    LayoutManager.prototype.getStyleOverridesForIndex = function (index) {\n        return undefined;\n    };\n    return LayoutManager;\n}());\nexports.LayoutManager = LayoutManager;\nvar WrapGridLayoutManager = /** @class */ (function (_super) {\n    __extends(WrapGridLayoutManager, _super);\n    function WrapGridLayoutManager(layoutProvider, renderWindowSize, isHorizontal, cachedLayouts) {\n        if (isHorizontal === void 0) { isHorizontal = false; }\n        var _this = _super.call(this) || this;\n        _this._layoutProvider = layoutProvider;\n        _this._window = renderWindowSize;\n        _this._totalHeight = 0;\n        _this._totalWidth = 0;\n        _this._isHorizontal = !!isHorizontal;\n        _this._layouts = cachedLayouts ? cachedLayouts : [];\n        return _this;\n    }\n    WrapGridLayoutManager.prototype.getContentDimension = function () {\n        return { height: this._totalHeight, width: this._totalWidth };\n    };\n    WrapGridLayoutManager.prototype.getLayouts = function () {\n        return this._layouts;\n    };\n    WrapGridLayoutManager.prototype.getOffsetForIndex = function (index) {\n        if (this._layouts.length > index) {\n            return { x: this._layouts[index].x, y: this._layouts[index].y };\n        }\n        else {\n            throw new CustomError_1.default({\n                message: \"No layout available for index: \" + index,\n                type: \"LayoutUnavailableException\",\n            });\n        }\n    };\n    WrapGridLayoutManager.prototype.overrideLayout = function (index, dim) {\n        var layout = this._layouts[index];\n        if (layout) {\n            layout.isOverridden = true;\n            layout.width = dim.width;\n            layout.height = dim.height;\n        }\n        return true;\n    };\n    WrapGridLayoutManager.prototype.setMaxBounds = function (itemDim) {\n        if (this._isHorizontal) {\n            itemDim.height = Math.min(this._window.height, itemDim.height);\n        }\n        else {\n            itemDim.width = Math.min(this._window.width, itemDim.width);\n        }\n    };\n    //TODO:Talha laziliy calculate in future revisions\n    WrapGridLayoutManager.prototype.relayoutFromIndex = function (startIndex, itemCount) {\n        startIndex = this._locateFirstNeighbourIndex(startIndex);\n        var startX = 0;\n        var startY = 0;\n        var maxBound = 0;\n        var startVal = this._layouts[startIndex];\n        if (startVal) {\n            startX = startVal.x;\n            startY = startVal.y;\n            this._pointDimensionsToRect(startVal);\n        }\n        var oldItemCount = this._layouts.length;\n        var itemDim = { height: 0, width: 0 };\n        var itemRect = null;\n        var oldLayout = null;\n        for (var i = startIndex; i < itemCount; i++) {\n            oldLayout = this._layouts[i];\n            var layoutType = this._layoutProvider.getLayoutTypeForIndex(i);\n            if (oldLayout && oldLayout.isOverridden && oldLayout.type === layoutType) {\n                itemDim.height = oldLayout.height;\n                itemDim.width = oldLayout.width;\n            }\n            else {\n                this._layoutProvider.setComputedLayout(layoutType, itemDim, i);\n            }\n            this.setMaxBounds(itemDim);\n            while (!this._checkBounds(startX, startY, itemDim, this._isHorizontal)) {\n                if (this._isHorizontal) {\n                    startX += maxBound;\n                    startY = 0;\n                    this._totalWidth += maxBound;\n                }\n                else {\n                    startX = 0;\n                    startY += maxBound;\n                    this._totalHeight += maxBound;\n                }\n                maxBound = 0;\n            }\n            maxBound = this._isHorizontal ? Math.max(maxBound, itemDim.width) : Math.max(maxBound, itemDim.height);\n            //TODO: Talha creating array upfront will speed this up\n            if (i > oldItemCount - 1) {\n                this._layouts.push({ x: startX, y: startY, height: itemDim.height, width: itemDim.width, type: layoutType });\n            }\n            else {\n                itemRect = this._layouts[i];\n                itemRect.x = startX;\n                itemRect.y = startY;\n                itemRect.type = layoutType;\n                itemRect.width = itemDim.width;\n                itemRect.height = itemDim.height;\n            }\n            if (this._isHorizontal) {\n                startY += itemDim.height;\n            }\n            else {\n                startX += itemDim.width;\n            }\n        }\n        if (oldItemCount > itemCount) {\n            this._layouts.splice(itemCount, oldItemCount - itemCount);\n        }\n        this._setFinalDimensions(maxBound);\n    };\n    WrapGridLayoutManager.prototype._pointDimensionsToRect = function (itemRect) {\n        if (this._isHorizontal) {\n            this._totalWidth = itemRect.x;\n        }\n        else {\n            this._totalHeight = itemRect.y;\n        }\n    };\n    WrapGridLayoutManager.prototype._setFinalDimensions = function (maxBound) {\n        if (this._isHorizontal) {\n            this._totalHeight = this._window.height;\n            this._totalWidth += maxBound;\n        }\n        else {\n            this._totalWidth = this._window.width;\n            this._totalHeight += maxBound;\n        }\n    };\n    WrapGridLayoutManager.prototype._locateFirstNeighbourIndex = function (startIndex) {\n        if (startIndex === 0) {\n            return 0;\n        }\n        var i = startIndex - 1;\n        for (; i >= 0; i--) {\n            if (this._isHorizontal) {\n                if (this._layouts[i].y === 0) {\n                    break;\n                }\n            }\n            else if (this._layouts[i].x === 0) {\n                break;\n            }\n        }\n        return i;\n    };\n    WrapGridLayoutManager.prototype._checkBounds = function (itemX, itemY, itemDim, isHorizontal) {\n        return isHorizontal ? (itemY + itemDim.height <= this._window.height) : (itemX + itemDim.width <= this._window.width);\n    };\n    return WrapGridLayoutManager;\n}(LayoutManager));\nexports.WrapGridLayoutManager = WrapGridLayoutManager;\n//# sourceMappingURL=LayoutManager.js.map"]},"metadata":{},"sourceType":"script"}