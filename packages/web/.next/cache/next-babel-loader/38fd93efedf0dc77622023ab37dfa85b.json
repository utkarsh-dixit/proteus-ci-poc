{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BinarySearch_1 = require(\"../utils/BinarySearch\");\n\nvar ViewabilityTracker =\n/** @class */\nfunction () {\n  function ViewabilityTracker(renderAheadOffset, initialOffset) {\n    var _this = this;\n\n    this._layouts = [];\n\n    this._valueExtractorForBinarySearch = function (index) {\n      var itemRect = _this._layouts[index];\n\n      _this._setRelevantBounds(itemRect, _this._relevantDim);\n\n      return _this._relevantDim.end;\n    };\n\n    this._currentOffset = Math.max(0, initialOffset);\n    this._maxOffset = 0;\n    this._actualOffset = 0;\n    this._renderAheadOffset = renderAheadOffset;\n    this._visibleWindow = {\n      start: 0,\n      end: 0\n    };\n    this._engagedWindow = {\n      start: 0,\n      end: 0\n    };\n    this._isHorizontal = false;\n    this._windowBound = 0;\n    this._visibleIndexes = []; //needs to be sorted\n\n    this._engagedIndexes = []; //needs to be sorted\n\n    this.onVisibleRowsChanged = null;\n    this.onEngagedRowsChanged = null;\n    this._relevantDim = {\n      start: 0,\n      end: 0\n    };\n  }\n\n  ViewabilityTracker.prototype.init = function () {\n    this._doInitialFit(this._currentOffset);\n  };\n\n  ViewabilityTracker.prototype.setLayouts = function (layouts, maxOffset) {\n    this._layouts = layouts;\n    this._maxOffset = maxOffset;\n  };\n\n  ViewabilityTracker.prototype.setDimensions = function (dimension, isHorizontal) {\n    this._isHorizontal = isHorizontal;\n    this._windowBound = isHorizontal ? dimension.width : dimension.height;\n  };\n\n  ViewabilityTracker.prototype.forceRefresh = function () {\n    var shouldForceScroll = this._currentOffset >= this._maxOffset - this._windowBound;\n    this.forceRefreshWithOffset(this._currentOffset);\n    return shouldForceScroll;\n  };\n\n  ViewabilityTracker.prototype.forceRefreshWithOffset = function (offset) {\n    this._currentOffset = -1;\n    this.updateOffset(offset, 0, false);\n  };\n\n  ViewabilityTracker.prototype.updateOffset = function (offset, correction, isActual) {\n    if (isActual) {\n      this._actualOffset = offset;\n    }\n\n    offset = Math.min(this._maxOffset, Math.max(0, offset + correction));\n\n    if (this._currentOffset !== offset) {\n      this._currentOffset = offset;\n\n      this._updateTrackingWindows(offset);\n\n      var startIndex = 0;\n\n      if (this._visibleIndexes.length > 0) {\n        startIndex = this._visibleIndexes[0];\n      }\n\n      this._fitAndUpdate(startIndex);\n    }\n  };\n\n  ViewabilityTracker.prototype.getLastOffset = function () {\n    return this._currentOffset;\n  };\n\n  ViewabilityTracker.prototype.getLastActualOffset = function () {\n    return this._actualOffset;\n  };\n\n  ViewabilityTracker.prototype.getEngagedIndexes = function () {\n    return this._engagedIndexes;\n  };\n\n  ViewabilityTracker.prototype.findFirstLogicallyVisibleIndex = function () {\n    var relevantIndex = this._findFirstVisibleIndexUsingBS(0.001);\n\n    var result = relevantIndex;\n\n    for (var i = relevantIndex - 1; i >= 0; i--) {\n      if (this._isHorizontal) {\n        if (this._layouts[relevantIndex].x !== this._layouts[i].x) {\n          break;\n        } else {\n          result = i;\n        }\n      } else {\n        if (this._layouts[relevantIndex].y !== this._layouts[i].y) {\n          break;\n        } else {\n          result = i;\n        }\n      }\n    }\n\n    return result;\n  };\n\n  ViewabilityTracker.prototype.updateRenderAheadOffset = function (renderAheadOffset) {\n    this._renderAheadOffset = Math.max(0, renderAheadOffset);\n    this.forceRefreshWithOffset(this._currentOffset);\n  };\n\n  ViewabilityTracker.prototype.getCurrentRenderAheadOffset = function () {\n    return this._renderAheadOffset;\n  };\n\n  ViewabilityTracker.prototype.setActualOffset = function (actualOffset) {\n    this._actualOffset = actualOffset;\n  };\n\n  ViewabilityTracker.prototype._findFirstVisibleIndexOptimally = function () {\n    var firstVisibleIndex = 0; //TODO: Talha calculate this value smartly\n\n    if (this._currentOffset > 5000) {\n      firstVisibleIndex = this._findFirstVisibleIndexUsingBS();\n    } else if (this._currentOffset > 0) {\n      firstVisibleIndex = this._findFirstVisibleIndexLinearly();\n    }\n\n    return firstVisibleIndex;\n  };\n\n  ViewabilityTracker.prototype._fitAndUpdate = function (startIndex) {\n    var newVisibleItems = [];\n    var newEngagedItems = [];\n\n    this._fitIndexes(newVisibleItems, newEngagedItems, startIndex, true);\n\n    this._fitIndexes(newVisibleItems, newEngagedItems, startIndex + 1, false);\n\n    this._diffUpdateOriginalIndexesAndRaiseEvents(newVisibleItems, newEngagedItems);\n  };\n\n  ViewabilityTracker.prototype._doInitialFit = function (offset) {\n    offset = Math.min(this._maxOffset, Math.max(0, offset));\n\n    this._updateTrackingWindows(offset);\n\n    var firstVisibleIndex = this._findFirstVisibleIndexOptimally();\n\n    this._fitAndUpdate(firstVisibleIndex);\n  }; //TODO:Talha switch to binary search and remove atleast once logic in _fitIndexes\n\n\n  ViewabilityTracker.prototype._findFirstVisibleIndexLinearly = function () {\n    var count = this._layouts.length;\n    var itemRect = null;\n    var relevantDim = {\n      start: 0,\n      end: 0\n    };\n\n    for (var i = 0; i < count; i++) {\n      itemRect = this._layouts[i];\n\n      this._setRelevantBounds(itemRect, relevantDim);\n\n      if (this._itemIntersectsVisibleWindow(relevantDim.start, relevantDim.end)) {\n        return i;\n      }\n    }\n\n    return 0;\n  };\n\n  ViewabilityTracker.prototype._findFirstVisibleIndexUsingBS = function (bias) {\n    if (bias === void 0) {\n      bias = 0;\n    }\n\n    var count = this._layouts.length;\n    return BinarySearch_1.default.findClosestHigherValueIndex(count, this._visibleWindow.start + bias, this._valueExtractorForBinarySearch);\n  }; //TODO:Talha Optimize further in later revisions, alteast once logic can be replace with a BS lookup\n\n\n  ViewabilityTracker.prototype._fitIndexes = function (newVisibleIndexes, newEngagedIndexes, startIndex, isReverse) {\n    var count = this._layouts.length;\n    var relevantDim = {\n      start: 0,\n      end: 0\n    };\n    var i = 0;\n    var atLeastOneLocated = false;\n\n    if (startIndex < count) {\n      if (!isReverse) {\n        for (i = startIndex; i < count; i++) {\n          if (this._checkIntersectionAndReport(i, false, relevantDim, newVisibleIndexes, newEngagedIndexes)) {\n            atLeastOneLocated = true;\n          } else {\n            if (atLeastOneLocated) {\n              break;\n            }\n          }\n        }\n      } else {\n        for (i = startIndex; i >= 0; i--) {\n          if (this._checkIntersectionAndReport(i, true, relevantDim, newVisibleIndexes, newEngagedIndexes)) {\n            atLeastOneLocated = true;\n          } else {\n            if (atLeastOneLocated) {\n              break;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  ViewabilityTracker.prototype._checkIntersectionAndReport = function (index, insertOnTop, relevantDim, newVisibleIndexes, newEngagedIndexes) {\n    var itemRect = this._layouts[index];\n    var isFound = false;\n\n    this._setRelevantBounds(itemRect, relevantDim);\n\n    if (this._itemIntersectsVisibleWindow(relevantDim.start, relevantDim.end)) {\n      if (insertOnTop) {\n        newVisibleIndexes.splice(0, 0, index);\n        newEngagedIndexes.splice(0, 0, index);\n      } else {\n        newVisibleIndexes.push(index);\n        newEngagedIndexes.push(index);\n      }\n\n      isFound = true;\n    } else if (this._itemIntersectsEngagedWindow(relevantDim.start, relevantDim.end)) {\n      //TODO: This needs to be optimized\n      if (insertOnTop) {\n        newEngagedIndexes.splice(0, 0, index);\n      } else {\n        newEngagedIndexes.push(index);\n      }\n\n      isFound = true;\n    }\n\n    return isFound;\n  };\n\n  ViewabilityTracker.prototype._setRelevantBounds = function (itemRect, relevantDim) {\n    if (this._isHorizontal) {\n      relevantDim.end = itemRect.x + itemRect.width;\n      relevantDim.start = itemRect.x;\n    } else {\n      relevantDim.end = itemRect.y + itemRect.height;\n      relevantDim.start = itemRect.y;\n    }\n  };\n\n  ViewabilityTracker.prototype._isItemInBounds = function (window, itemBound) {\n    return window.start < itemBound && window.end > itemBound;\n  };\n\n  ViewabilityTracker.prototype._isItemBoundsBeyondWindow = function (window, startBound, endBound) {\n    return window.start >= startBound && window.end <= endBound;\n  };\n\n  ViewabilityTracker.prototype._itemIntersectsWindow = function (window, startBound, endBound) {\n    return this._isItemInBounds(window, startBound) || this._isItemInBounds(window, endBound) || this._isItemBoundsBeyondWindow(window, startBound, endBound);\n  };\n\n  ViewabilityTracker.prototype._itemIntersectsEngagedWindow = function (startBound, endBound) {\n    return this._itemIntersectsWindow(this._engagedWindow, startBound, endBound);\n  };\n\n  ViewabilityTracker.prototype._itemIntersectsVisibleWindow = function (startBound, endBound) {\n    return this._itemIntersectsWindow(this._visibleWindow, startBound, endBound);\n  };\n\n  ViewabilityTracker.prototype._updateTrackingWindows = function (newOffset) {\n    this._engagedWindow.start = Math.max(0, newOffset - this._renderAheadOffset);\n    this._engagedWindow.end = newOffset + this._windowBound + this._renderAheadOffset;\n    this._visibleWindow.start = newOffset;\n    this._visibleWindow.end = newOffset + this._windowBound;\n  }; //TODO:Talha optimize this\n\n\n  ViewabilityTracker.prototype._diffUpdateOriginalIndexesAndRaiseEvents = function (newVisibleItems, newEngagedItems) {\n    this._diffArraysAndCallFunc(newVisibleItems, this._visibleIndexes, this.onVisibleRowsChanged);\n\n    this._diffArraysAndCallFunc(newEngagedItems, this._engagedIndexes, this.onEngagedRowsChanged);\n\n    this._visibleIndexes = newVisibleItems;\n    this._engagedIndexes = newEngagedItems;\n  };\n\n  ViewabilityTracker.prototype._diffArraysAndCallFunc = function (newItems, oldItems, func) {\n    if (func) {\n      var now = this._calculateArrayDiff(newItems, oldItems);\n\n      var notNow = this._calculateArrayDiff(oldItems, newItems);\n\n      if (now.length > 0 || notNow.length > 0) {\n        func(newItems.slice(), now, notNow);\n      }\n    }\n  }; //TODO:Talha since arrays are sorted this can be much faster\n\n\n  ViewabilityTracker.prototype._calculateArrayDiff = function (arr1, arr2) {\n    var len = arr1.length;\n    var diffArr = [];\n\n    for (var i = 0; i < len; i++) {\n      if (BinarySearch_1.default.findIndexOf(arr2, arr1[i]) === -1) {\n        diffArr.push(arr1[i]);\n      }\n    }\n\n    return diffArr;\n  };\n\n  return ViewabilityTracker;\n}();\n\nexports.default = ViewabilityTracker;","map":{"version":3,"sources":["../../../src/core/ViewabilityTracker.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BinarySearch_1 = require(\"../utils/BinarySearch\");\nvar ViewabilityTracker = /** @class */ (function () {\n    function ViewabilityTracker(renderAheadOffset, initialOffset) {\n        var _this = this;\n        this._layouts = [];\n        this._valueExtractorForBinarySearch = function (index) {\n            var itemRect = _this._layouts[index];\n            _this._setRelevantBounds(itemRect, _this._relevantDim);\n            return _this._relevantDim.end;\n        };\n        this._currentOffset = Math.max(0, initialOffset);\n        this._maxOffset = 0;\n        this._actualOffset = 0;\n        this._renderAheadOffset = renderAheadOffset;\n        this._visibleWindow = { start: 0, end: 0 };\n        this._engagedWindow = { start: 0, end: 0 };\n        this._isHorizontal = false;\n        this._windowBound = 0;\n        this._visibleIndexes = []; //needs to be sorted\n        this._engagedIndexes = []; //needs to be sorted\n        this.onVisibleRowsChanged = null;\n        this.onEngagedRowsChanged = null;\n        this._relevantDim = { start: 0, end: 0 };\n    }\n    ViewabilityTracker.prototype.init = function () {\n        this._doInitialFit(this._currentOffset);\n    };\n    ViewabilityTracker.prototype.setLayouts = function (layouts, maxOffset) {\n        this._layouts = layouts;\n        this._maxOffset = maxOffset;\n    };\n    ViewabilityTracker.prototype.setDimensions = function (dimension, isHorizontal) {\n        this._isHorizontal = isHorizontal;\n        this._windowBound = isHorizontal ? dimension.width : dimension.height;\n    };\n    ViewabilityTracker.prototype.forceRefresh = function () {\n        var shouldForceScroll = this._currentOffset >= (this._maxOffset - this._windowBound);\n        this.forceRefreshWithOffset(this._currentOffset);\n        return shouldForceScroll;\n    };\n    ViewabilityTracker.prototype.forceRefreshWithOffset = function (offset) {\n        this._currentOffset = -1;\n        this.updateOffset(offset, 0, false);\n    };\n    ViewabilityTracker.prototype.updateOffset = function (offset, correction, isActual) {\n        if (isActual) {\n            this._actualOffset = offset;\n        }\n        offset = Math.min(this._maxOffset, Math.max(0, offset + correction));\n        if (this._currentOffset !== offset) {\n            this._currentOffset = offset;\n            this._updateTrackingWindows(offset);\n            var startIndex = 0;\n            if (this._visibleIndexes.length > 0) {\n                startIndex = this._visibleIndexes[0];\n            }\n            this._fitAndUpdate(startIndex);\n        }\n    };\n    ViewabilityTracker.prototype.getLastOffset = function () {\n        return this._currentOffset;\n    };\n    ViewabilityTracker.prototype.getLastActualOffset = function () {\n        return this._actualOffset;\n    };\n    ViewabilityTracker.prototype.getEngagedIndexes = function () {\n        return this._engagedIndexes;\n    };\n    ViewabilityTracker.prototype.findFirstLogicallyVisibleIndex = function () {\n        var relevantIndex = this._findFirstVisibleIndexUsingBS(0.001);\n        var result = relevantIndex;\n        for (var i = relevantIndex - 1; i >= 0; i--) {\n            if (this._isHorizontal) {\n                if (this._layouts[relevantIndex].x !== this._layouts[i].x) {\n                    break;\n                }\n                else {\n                    result = i;\n                }\n            }\n            else {\n                if (this._layouts[relevantIndex].y !== this._layouts[i].y) {\n                    break;\n                }\n                else {\n                    result = i;\n                }\n            }\n        }\n        return result;\n    };\n    ViewabilityTracker.prototype.updateRenderAheadOffset = function (renderAheadOffset) {\n        this._renderAheadOffset = Math.max(0, renderAheadOffset);\n        this.forceRefreshWithOffset(this._currentOffset);\n    };\n    ViewabilityTracker.prototype.getCurrentRenderAheadOffset = function () {\n        return this._renderAheadOffset;\n    };\n    ViewabilityTracker.prototype.setActualOffset = function (actualOffset) {\n        this._actualOffset = actualOffset;\n    };\n    ViewabilityTracker.prototype._findFirstVisibleIndexOptimally = function () {\n        var firstVisibleIndex = 0;\n        //TODO: Talha calculate this value smartly\n        if (this._currentOffset > 5000) {\n            firstVisibleIndex = this._findFirstVisibleIndexUsingBS();\n        }\n        else if (this._currentOffset > 0) {\n            firstVisibleIndex = this._findFirstVisibleIndexLinearly();\n        }\n        return firstVisibleIndex;\n    };\n    ViewabilityTracker.prototype._fitAndUpdate = function (startIndex) {\n        var newVisibleItems = [];\n        var newEngagedItems = [];\n        this._fitIndexes(newVisibleItems, newEngagedItems, startIndex, true);\n        this._fitIndexes(newVisibleItems, newEngagedItems, startIndex + 1, false);\n        this._diffUpdateOriginalIndexesAndRaiseEvents(newVisibleItems, newEngagedItems);\n    };\n    ViewabilityTracker.prototype._doInitialFit = function (offset) {\n        offset = Math.min(this._maxOffset, Math.max(0, offset));\n        this._updateTrackingWindows(offset);\n        var firstVisibleIndex = this._findFirstVisibleIndexOptimally();\n        this._fitAndUpdate(firstVisibleIndex);\n    };\n    //TODO:Talha switch to binary search and remove atleast once logic in _fitIndexes\n    ViewabilityTracker.prototype._findFirstVisibleIndexLinearly = function () {\n        var count = this._layouts.length;\n        var itemRect = null;\n        var relevantDim = { start: 0, end: 0 };\n        for (var i = 0; i < count; i++) {\n            itemRect = this._layouts[i];\n            this._setRelevantBounds(itemRect, relevantDim);\n            if (this._itemIntersectsVisibleWindow(relevantDim.start, relevantDim.end)) {\n                return i;\n            }\n        }\n        return 0;\n    };\n    ViewabilityTracker.prototype._findFirstVisibleIndexUsingBS = function (bias) {\n        if (bias === void 0) { bias = 0; }\n        var count = this._layouts.length;\n        return BinarySearch_1.default.findClosestHigherValueIndex(count, this._visibleWindow.start + bias, this._valueExtractorForBinarySearch);\n    };\n    //TODO:Talha Optimize further in later revisions, alteast once logic can be replace with a BS lookup\n    ViewabilityTracker.prototype._fitIndexes = function (newVisibleIndexes, newEngagedIndexes, startIndex, isReverse) {\n        var count = this._layouts.length;\n        var relevantDim = { start: 0, end: 0 };\n        var i = 0;\n        var atLeastOneLocated = false;\n        if (startIndex < count) {\n            if (!isReverse) {\n                for (i = startIndex; i < count; i++) {\n                    if (this._checkIntersectionAndReport(i, false, relevantDim, newVisibleIndexes, newEngagedIndexes)) {\n                        atLeastOneLocated = true;\n                    }\n                    else {\n                        if (atLeastOneLocated) {\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                for (i = startIndex; i >= 0; i--) {\n                    if (this._checkIntersectionAndReport(i, true, relevantDim, newVisibleIndexes, newEngagedIndexes)) {\n                        atLeastOneLocated = true;\n                    }\n                    else {\n                        if (atLeastOneLocated) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n    ViewabilityTracker.prototype._checkIntersectionAndReport = function (index, insertOnTop, relevantDim, newVisibleIndexes, newEngagedIndexes) {\n        var itemRect = this._layouts[index];\n        var isFound = false;\n        this._setRelevantBounds(itemRect, relevantDim);\n        if (this._itemIntersectsVisibleWindow(relevantDim.start, relevantDim.end)) {\n            if (insertOnTop) {\n                newVisibleIndexes.splice(0, 0, index);\n                newEngagedIndexes.splice(0, 0, index);\n            }\n            else {\n                newVisibleIndexes.push(index);\n                newEngagedIndexes.push(index);\n            }\n            isFound = true;\n        }\n        else if (this._itemIntersectsEngagedWindow(relevantDim.start, relevantDim.end)) {\n            //TODO: This needs to be optimized\n            if (insertOnTop) {\n                newEngagedIndexes.splice(0, 0, index);\n            }\n            else {\n                newEngagedIndexes.push(index);\n            }\n            isFound = true;\n        }\n        return isFound;\n    };\n    ViewabilityTracker.prototype._setRelevantBounds = function (itemRect, relevantDim) {\n        if (this._isHorizontal) {\n            relevantDim.end = itemRect.x + itemRect.width;\n            relevantDim.start = itemRect.x;\n        }\n        else {\n            relevantDim.end = itemRect.y + itemRect.height;\n            relevantDim.start = itemRect.y;\n        }\n    };\n    ViewabilityTracker.prototype._isItemInBounds = function (window, itemBound) {\n        return (window.start < itemBound && window.end > itemBound);\n    };\n    ViewabilityTracker.prototype._isItemBoundsBeyondWindow = function (window, startBound, endBound) {\n        return (window.start >= startBound && window.end <= endBound);\n    };\n    ViewabilityTracker.prototype._itemIntersectsWindow = function (window, startBound, endBound) {\n        return this._isItemInBounds(window, startBound) ||\n            this._isItemInBounds(window, endBound) ||\n            this._isItemBoundsBeyondWindow(window, startBound, endBound);\n    };\n    ViewabilityTracker.prototype._itemIntersectsEngagedWindow = function (startBound, endBound) {\n        return this._itemIntersectsWindow(this._engagedWindow, startBound, endBound);\n    };\n    ViewabilityTracker.prototype._itemIntersectsVisibleWindow = function (startBound, endBound) {\n        return this._itemIntersectsWindow(this._visibleWindow, startBound, endBound);\n    };\n    ViewabilityTracker.prototype._updateTrackingWindows = function (newOffset) {\n        this._engagedWindow.start = Math.max(0, newOffset - this._renderAheadOffset);\n        this._engagedWindow.end = newOffset + this._windowBound + this._renderAheadOffset;\n        this._visibleWindow.start = newOffset;\n        this._visibleWindow.end = newOffset + this._windowBound;\n    };\n    //TODO:Talha optimize this\n    ViewabilityTracker.prototype._diffUpdateOriginalIndexesAndRaiseEvents = function (newVisibleItems, newEngagedItems) {\n        this._diffArraysAndCallFunc(newVisibleItems, this._visibleIndexes, this.onVisibleRowsChanged);\n        this._diffArraysAndCallFunc(newEngagedItems, this._engagedIndexes, this.onEngagedRowsChanged);\n        this._visibleIndexes = newVisibleItems;\n        this._engagedIndexes = newEngagedItems;\n    };\n    ViewabilityTracker.prototype._diffArraysAndCallFunc = function (newItems, oldItems, func) {\n        if (func) {\n            var now = this._calculateArrayDiff(newItems, oldItems);\n            var notNow = this._calculateArrayDiff(oldItems, newItems);\n            if (now.length > 0 || notNow.length > 0) {\n                func(newItems.slice(), now, notNow);\n            }\n        }\n    };\n    //TODO:Talha since arrays are sorted this can be much faster\n    ViewabilityTracker.prototype._calculateArrayDiff = function (arr1, arr2) {\n        var len = arr1.length;\n        var diffArr = [];\n        for (var i = 0; i < len; i++) {\n            if (BinarySearch_1.default.findIndexOf(arr2, arr1[i]) === -1) {\n                diffArr.push(arr1[i]);\n            }\n        }\n        return diffArr;\n    };\n    return ViewabilityTracker;\n}());\nexports.default = ViewabilityTracker;\n//# sourceMappingURL=ViewabilityTracker.js.map"]},"metadata":{},"sourceType":"script"}